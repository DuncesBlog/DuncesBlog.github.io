
# 752. 打开转盘锁 [中等][广搜]
    该文创建于 2024/07/09
题目地址:[打开转盘锁](https://leetcode.cn/problems/open-the-lock)

## 题目描述
    你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。
    每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。

    锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。

    列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

    字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。

    示例 1:
        输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"
        输出：6
        解释：
            可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。
            注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，
            因为当拨动到 "0102" 时这个锁就会被锁定。
    示例 2:
        输入: deadends = ["8888"], target = "0009"
        输出：1
        解释：把最后一位反向旋转一次即可 "0000" -> "0009"。
    示例 3:
        输入: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
        输出：-1
        解释：无法旋转到目标数字且不被锁定。

## 解题思路
### 初始思路
    模拟题，首先想到的就是 深搜 和 广搜， 深搜 是在一种分支情况下再次模拟，肯定会超时的
    and，在两种搜索的情况下，都要考虑一个情况：曾经模拟过的情况不能再次被模拟出来，不然就死循环了，所以一定要创建一个history来记录
    
    由描述可知，四个拨轮，每次可以旋转一个拨轮的一位数字，可以旋转的方向即 +1 和 -1；轮盘，0 -1 是 9，且与其他拨轮无关
    所以一共由 8 种情况；且 反向拨1 和 正向拨9 是一样的，所以拨轮上的操作可以写作
        （k + 1）% 10 或 （k + 9）& 10
    每一次波动的方案可以看成一个 分支数为 8 的 树
    广搜的逻辑就是，按深度遍历这个树，所以想构造一个list列表存放某深度的所有元素
    元素的构成呢，首先要有元素值value，所在树的深度depth，还要有能方便查找历史值的功能，存它的父节点father，可以遍历father.value来判断
    （关于历史值的问题，有考虑用一个list来存储，后觉得每一个node都存了一个list，重复值太多太耗费内存了）
    
``` C# 内存不足
class Node
{
    public Node father;
    public string value;
    public int depth;
}
/// <summary>
/// 广搜,提交后内存不足
/// </summary>
public int OpenLock_BFS(string[] deadends, string target)
{
    var deadendsList = deadends.ToList();

    bool checkIsOldValue(Node fnode, string value)
    {
        if (deadendsList.Contains(value))
        {
            return true;
        }
        
        while (fnode != null)
        {
            if (fnode.value == value)
            {
                return true;
            }

            fnode = fnode.father;
        }

        return false;
    }
    
    Node BFS(List<Node> NodeList)
    {
        List<Node> BFSList = new List<Node>();
        foreach (var node in NodeList)
        {
            if (checkIsOldValue(node.father, node.value))
            {
                continue;
            }
            
            if (node.value == "0000")
            {
                return node;
            }

            var nowTarget = node.value;
            
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{((int) nowTarget[0] - (int) '0' + 1)%10}{nowTarget[1]}{nowTarget[2]}{nowTarget[3]}"});
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{((int) nowTarget[0] - (int) '0' + 9)%10}{nowTarget[1]}{nowTarget[2]}{nowTarget[3]}"});
            
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{nowTarget[0]}{((int) nowTarget[1] - (int) '0' + 1)%10}{nowTarget[2]}{nowTarget[3]}"});
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{nowTarget[0]}{((int) nowTarget[1] - (int) '0' + 9)%10}{nowTarget[2]}{nowTarget[3]}"});
            
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{((int) nowTarget[2] - (int) '0' + 1)%10}{nowTarget[3]}"});
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{((int) nowTarget[2] - (int) '0' + 9)%10}{nowTarget[3]}"});
            
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{nowTarget[2]}{((int) nowTarget[3] - (int) '0' + 1)%10}" });
            BFSList.Add(new Node(){father = node, depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{nowTarget[2]}{((int) nowTarget[3] - (int) '0' + 9)%10}"});
            
        }

        if (BFSList.Count == 0)
        {
            return null;
        }

        return BFS(BFSList);
    }
    
    Node targetNode = new Node() {father = null, value = target, depth = 0};

    var endNode = BFS(new List<Node>() {targetNode});

    return endNode == null ? -1 : endNode.depth;
}
```


### 第一版优化
    看到以前的代码,history历史既然被其他分支模拟过,那后面的结果肯定是一样的,历史的那次的模拟深度不可能高于当前,so

    1.node.history 改 通用historyList. 既然当前这个值在其他分支的history上便利过了,那么肯定比当前的分支的路径要浅(超时了……)
    2.history 的list 改为 状态数组,list在增加的时候还要开辟空间,开辟空间就有复制粘贴的时间浪费,不如开个状态数组,所有值范围在0~9999之间
    3.递归改while(也过了) 但是时间要多,内存也大（用时 253ms -> 208ms, 内存 87.9MB -> 82.5MB）

    and 从target到0就有错,从0到target就没有,初始的死亡密码就有0,没操作直接无法旋转,而开锁密码时死亡密码则不同,无法旋转就不旋转了,反正锁已经开了!!! 不细心马虎的坑!!!
``` C# 执行用时:208ms 消耗内存:82.5M
class Node_2
{
    public string value;
    public int depth;
}
public int OpenLock_OK_1(string[] deadends, string target)
{
    int[] historyArr = new int[10000];
    foreach (var deadend in deadends)
    {
        historyArr[int.Parse(deadend)] = -1;
    }
    

    Queue<Node_2> BFSQueue = new Queue<Node_2>();
    BFSQueue.Enqueue(new Node_2() {value = "0000", depth = 0});

    while (BFSQueue.Count > 0)
    {
        Node_2 node = BFSQueue.Dequeue();
        if (node.value == target) return node.depth;
        if (historyArr[int.Parse(node.value)] == -1)
        {
            continue;
        }

        historyArr[int.Parse(node.value)] = -1;
        var nowTarget = node.value;
            
        BFSQueue.Enqueue(new Node_2(){depth = node.depth+1, value = $"{((int) nowTarget[0] - (int) '0' + 1)%10}{nowTarget[1]}{nowTarget[2]}{nowTarget[3]}"});
        BFSQueue.Enqueue(new Node_2(){depth = node.depth+1, value = $"{((int) nowTarget[0] - (int) '0' + 9)%10}{nowTarget[1]}{nowTarget[2]}{nowTarget[3]}"});
            
        BFSQueue.Enqueue(new Node_2(){depth = node.depth+1, value = $"{nowTarget[0]}{((int) nowTarget[1] - (int) '0' + 1)%10}{nowTarget[2]}{nowTarget[3]}"});
        BFSQueue.Enqueue(new Node_2(){depth = node.depth+1, value = $"{nowTarget[0]}{((int) nowTarget[1] - (int) '0' + 9)%10}{nowTarget[2]}{nowTarget[3]}"});
            
        BFSQueue.Enqueue(new Node_2(){ depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{((int) nowTarget[2] - (int) '0' + 1)%10}{nowTarget[3]}"});
        BFSQueue.Enqueue(new Node_2(){depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{((int) nowTarget[2] - (int) '0' + 9)%10}{nowTarget[3]}"});
            
        BFSQueue.Enqueue(new Node_2(){depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{nowTarget[2]}{((int) nowTarget[3] - (int) '0' + 1)%10}" });
        BFSQueue.Enqueue(new Node_2(){depth = node.depth+1, value = $"{nowTarget[0]}{nowTarget[1]}{nowTarget[2]}{((int) nowTarget[3] - (int) '0' + 9)%10}"});
        
    }

    return -1;
}
```


### 第二版优化
    1.把频繁的字符串转换全部修改为对 int 类型,执行时间大大优化,由208ms优化至100ms;内存消耗(82.5M to 73M)
    2.对 下一层数据 的先塞后算 改为 先算后塞,执行用时(100 to 79)和内存消耗(73M to 54M)也被优化了
``` C#
class Node_3
{
    public int value;
    public int depth;
}
public int OpenLock(string[] deadends, string target)
{
    int[] historyArr = new int[10000];
    foreach (var deadend in deadends)
    {
        historyArr[int.Parse(deadend)] = -1;
    }
    historyArr[int.Parse(target)] = 1;
    
    if (historyArr[0] == 1) return 0;
    if (historyArr[0] == -1) return -1;

    Queue<Node_3> BFSQueue = new Queue<Node_3>();
    BFSQueue.Enqueue(new Node_3() {value = 0, depth = 0});

    while (BFSQueue.Count > 0)
    {
        Node_3 node = BFSQueue.Dequeue();

        var nextArr = getNextArr(node.value);
        foreach (var i in nextArr)
        {
            if (historyArr[i] == 1) return node.depth+1;
            if (historyArr[i] == -1)
            {
                continue;
            }

            historyArr[i] = -1;
            BFSQueue.Enqueue(new Node_3() {depth = node.depth + 1, value = i});
        }
    }

    return -1;

    int[] getNextArr(int nowTarget)
    {
        int[] arr = new int[8];
        arr[0] = (int) (nowTarget / 10) * 10 + (nowTarget % 10 + 1) % 10;
        arr[1] = (int) (nowTarget / 10)*10 + (nowTarget%10 + 9)%10;
        arr[2] = (nowTarget / 100)*100 + (nowTarget%100 + 10)%100;
        arr[3] = (nowTarget / 100) * 100 + (nowTarget % 100 + 90) % 100;
        arr[4] = (nowTarget / 1000) * 1000 + (nowTarget % 1000 + 100) % 1000;
        arr[5] = (nowTarget / 1000)*1000 + (nowTarget%1000 + 900)%1000;
        arr[6] = (nowTarget + 1000)%10000;
        arr[7] = (nowTarget + 9000)%10000;
        return arr;
    }
}
```




## 恶趣味了
    emmmm,附一下DFS的,本地都栈溢出了,答案?那就更不知道对不对了
``` C#
public int OpenLock_DFS(string[] deadends, string target)
{
    var deadendsList = deadends.ToList();

    List<string> DFS(List<string> history, string nowTarget)
    {
        if (nowTarget == "0000")
        {
            return history;
        }
        
        if (deadendsList.Contains(nowTarget) || history.Contains(nowTarget))
        {
            return null;
        }
        history.Add(nowTarget);

        var r1 = DFS(history, $"{((int) nowTarget[0] - (int) '0' + 1)%10}{nowTarget[1]}{nowTarget[2]}{nowTarget[3]}" );
        var r2 = DFS(history, $"{((int) nowTarget[0] - (int) '0' + 9)%10}{nowTarget[1]}{nowTarget[2]}{nowTarget[3]}" );
        
        var r3 = DFS(history, $"{nowTarget[0]}{((int) nowTarget[1] - (int) '0' + 1)%10}{nowTarget[2]}{nowTarget[3]}" );
        var r4 = DFS(history, $"{nowTarget[0]}{((int) nowTarget[1] - (int) '0' + 9)%10}{nowTarget[2]}{nowTarget[3]}");
        
        var r5 = DFS(history, $"{nowTarget[0]}{nowTarget[1]}{((int) nowTarget[2] - (int) '0' + 1)%10}{nowTarget[3]}" );
        var r6 = DFS(history, $"{nowTarget[0]}{nowTarget[1]}{((int) nowTarget[2] - (int) '0' + 9)%10}{nowTarget[3]}" );
        
        var r7 = DFS(history, $"{nowTarget[0]}{nowTarget[1]}{nowTarget[2]}{((int) nowTarget[3] - (int) '0' + 1)%10}" );
        var r8 = DFS(history, $"{nowTarget[0]}{nowTarget[1]}{nowTarget[2]}{((int) nowTarget[3] - (int) '0' + 9)%10}" );

        var resultArr = new List<List<string>>(){r1, r2, r3, r4, r5, r6, r7, r8};
        List<string> lujing = null;
        foreach (var resItem in resultArr)
        {
            if(resItem == null) continue;
            if (lujing == null || resItem.Count < lujing.Count)
            {
                lujing = resItem;
            }
        }
        
        return lujing;
    }

    var result = DFS(new List<string>(), target);

    return result == null ? -1 : result.Count;
}
```
