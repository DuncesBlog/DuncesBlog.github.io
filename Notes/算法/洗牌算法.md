
# 洗牌算法(Knuth_Durstenfeld算法) shuffle
    洗牌算法是一种将数组内所有元素均匀的打乱的一种算法
    文章参考
        [YF云飞](https://blog.csdn.net/flyTie/article/details/126548063)
        [寂灭万乘](https://www.cnblogs.com/millionsmultiplication/p/9570258.html)

## 逻辑
    每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部(未处理的尾部,与之交换元素)， 即数组尾部存放的是已经处理过的数字 。
    （因为生成 [0, i] 范围的随机数比生成 [i, n) 范围的随机数简单，所以 处理过的数字放在尾部^~^）
    
    优点: 这是一个原地打乱顺序的算法，且每一个元素出现在每一个位置的概率相同
    缺点: 嗯？？？
    时间复杂度: O(n)
    空间复杂度: O(1)

    尝试验证概率相同
    数组元素是 A,B,C,D,E    数组长度:5
    假如第1个随机元素是A,A被选中的概率为: 1/5
    假如第2个随机元素是B,B被选中的概率为: B没被上次随机选中的概率(4/5),并且B被这次选中的概率(1/4)
        4/5 * 1/4 = 1/5
    假设第3个随机元素是C,C被选中的概率为: C没被第1次选中(4/5),还没被第2次选中(3/4),并且被这次选中的概率(1/3)
        4/5 * 3/4 * 1/3 = 1/5
    ……
    以此类推,实现洗牌后每个元素在它所在的位置的概率都是1/5



## 代码
``` JavaScript
var arrLen = ItemArr.length;
for(var i=0; i<arrLen; i++) {
    var lastIndex = arrLen - 1 - i;
    var index = Math.floor(Math.random() * lastIndex);

    var t = ItemArr[index];
    ItemArr[index] = ItemArr[lastIndex];
    ItemArr[lastIndex] = t;
}
```

## 其他的洗牌算法

### 抽牌洗牌法
    抽出牌库的最后一张牌,随机的插入到牌库里,一般是循环N遍

    优点: 逻辑简单
    缺点: 每一次插入都需要大量的移动元素,且无法保证所有的牌被洗到
    时间复杂度: O(N^2)
    空间复杂度: O(1)

### Fisher_Yates算法
    创建两个列表，一个洗牌前A，一个洗牌后B，B初始为空
    随机从A取一张放入B尾
    直到A被取空
    
    优点: 算法原理清晰，通过54次生成的随机数取1/54,1/53,…1/1能等概率地生成这54!种结果中的一种。
    缺点: 额外开辟了一个List，而且为List删除元素是不可避免地需要移动元素。
    时间复杂度: O(N^2)???
    空间复杂度: O(N)